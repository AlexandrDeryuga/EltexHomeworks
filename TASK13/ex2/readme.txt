Задания на очереди сообщений, мессенджер

1. Начал с простого в system V, использовал там две очереди, хотя легко можно было обойтись одной
2. В posix показалось слишком просто , и из спортивного интереса обошелся одной очередью -  

3. Создать месенджер - вот здесь по неопытности столкнулся с кучей проблем,  и быстро нарастающей сложности, убил кучу времени и
в итоге сделал "лишь бы формально работало", очень некрасивого  и проблемного кода, показывающего как делать не надо. :)
От попытки все реализовать в общем случае отказался из за возникших сложностей, хотя в архитектуре заложенно на полноценный месенджер.

ОШИБКИ и ВЫВОДЫ:
1 - недостаточно четкое проектирование на бумаге, проблемы с архитектурой + ошибки в ней,+ в какой то момент  
    структуры сообщения пид-клиент оказалось недостаточно 
2 - Начал с интерфейса, с переделки файлового менеджера, в итоге потом была архитектурная отладка с большой кучей кода
3.- Слишком раннее разделение на клиента и сервера, типа посмотреть что получилось. В итоге архитектурные правки пришлось вносит сразу в 2 
экземпляра. да и просто  беспорядок и путаница в почти одинаковом коде.
4. Поленился продумать функции, это упростило бы отладку

ИДЕЯ И АЛГОРИТМ РАБОТЫ
1. клиент и сервер это программы с одним интерфейсом, 
2. Ядро  программы - модуль dinamic_msg.c и структура данных, описывающая клиента как чат комнату, комнаты между клиентами в общем случае это тот же обьект
   чат-комната, со свойством privat, что бы потом остальным была не видна. Сообщения в комнате компануются в динамически выделяемую память,подряд
   но есть указатель на начало области и список смещений относительно него на каждое сообщение.

3.Общая комната вынесена отдельно и имеет ID 0, остальные клиенты имеют ID - pid процесса, в общем случае это не совсем правильно, но сделал так.

4. Итак имеем два приложения - КЛИЕНТ и Сервер, в каждом приложении 2 потока плюс основной(отвечающий за интерфейс) итого 3 потока на приложение. Взаимодействующие между собой по стандарту systemV ( идеально ложиться на архитектуру клиент - сервер)

    Задача потока 1 -  слушать регистрацию клиентов, очередь сообщений 1 + управляющие команды
    Задача потока 2 - обмен сообщениями, очередь сообщений 2 + управляющие команды
    
    Каждая очередь (и процесс) пработают в режиме  вопрос-ответ, т.е. по умолчанию мы слушаем очередь, и если что то считываем из нее - выполняем соответствующее действия
    в итоге , появились мета-команды между потоками - , например "send_msg" говорит потоку 2 сервера что нужно разослать последнее сообщение из чат-комнаты 
   (от сервера) всем клиентам, или команда " exit" говорит потоку что будем завершаться. Или команда от процесса 1 процессу 2  что появился новый клиент, 
   и нужно ему скинуть все сообщения из чат комнаты. Это механизм общения между потоками в одном приложении.
   
  5. Взаимодействие между приложениями устроено так - клиент отсылает серверу сообщение, которое тот добавляет в свою чат комнату,  и уже потом синхронизирует чат комнаты между всеми клиентами, включая того которой ему данное сообщение послал
  Стандартное сообщеие от коиента выглядит так [свой_pid кому_pid/0 сообщение] 0 - для общей комнаты
  
  В итоге, сервер зная кто послал может отправить этому же клиенту ответку, (что даже не нужно оказалось) но пририсовывает к сообщению расшифровку - имя клиента (нужно).
  
  Ну вот. Из этого пришлось все ускорять, и реализованно только общие механизмы и то что касается общей чат комнаты, где то не до конца раскиданы мьютекчы по графике( отрисовка сбоит) , приложения не договариваются между собой о корректном выходе, нет механизма блокировок чат комнат ну и 
  сам код надо сделать нормальным, сейчас там бардак.
        
