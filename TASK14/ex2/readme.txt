Переписать месенджер на динамической памяти

Создан модуль аналог очередей систем V на динамической памяти, в архитектуру заложен функцианал общего случая,
но отестированы варианты чтения - с блокировкой, и запись в очередь, поскольку именно в таком варианте функционала они были использованы в мессенджере

В самом месенджее ничего не менял, просто заменил  функции на аналоги, и подкорректировал проверки на возращаемые ошибки (возвращаемые значения слегка разные).

typedef struct myQsys_type   //вид структуры
{
int mcount;  //счетчик сообщений
int shm_fd;//id для разделяемой памяти
void *addr; // адрес разделяемой памяти
char  name[256];
msgbuf SM_system[SH_SYSMSG_MAX];
} myQsys_type;


int Qsys_msgsnd( myQsys_type * Q,msgbuf * msg_struct, int wait, float sleeptime )   // аналоги для очереди  (системные сообщения - маленький буфер)
int Q_msgsnd( myQmsg_type * Q,msgBigBuf * msg_struct, int wait, float sleeptime )   // аналоги для очереди (сообщения - большой буфер)   
int Qsys_msgrcv( myQsys_type * Q, msgbuf *buf, char wait,float sleeptime, int type ) //
wait - параметр помогает реализовать логику nowait
sleeptime- указывает на сколько функции засыпать, после посылки сообщения, что бы другие потребители могли считать из очереди

+ вспомогательный функции на создание и удаление очереди, а так же мониторинга ее состояния

Пример использования:  (он же закоментирован в модуле  RTEST который в реальности и используется в мессенджере, -
ИЗНАЧАЛЬНО МОДУЛЬ КОМПИЛИРОВАЛСЯ И ТЕСТИРОВАЛСЯ ОТДЕЛЬНО)

int main ()
{
int i;
msgbuf m,mm;
myQsys_type *Q;
myQsys_type q;
Q=Qsys_open("my_shared",0) ; //первое создание очереди
printf("===Qtest====\n");
printQ(Q);//1
m.mType=1;strcpy(m.mText,"тест 1 тип 1");
Qsys_msgsnd( Q, &m, 0, 0.1);
m.mType=1;strcpy(m.mText,"тест 2 тип 1");
Qsys_msgsnd( Q, &m, 0, 0.1);
m.mType=2;strcpy(m.mText,"тест 3 тип 2");
Qsys_msgsnd( Q, &m, 0, 0.1);
printQ(Q);//2

m.mType=1;int tt=Qsys_msgrcv(Q,&mm,1,0.1, m.mType ); //считаем     
printf("считал из  из очереди тип=%2ld >%s<  вернули код=%d\n",m.mType,mm.mText,tt);
printQ(Q);


m.mType=2;strcpy(m.mText,"тест 4 тип 2");
Qsys_msgsnd( Q, &m, 0, 0.1);
printQ(Q);

m.mType=1; tt=sys_msgrcv(Q,&mm,1,0.1, m.mType ); //считаем     
printf("считал из  из очереди тип=%2ld >%s<  вернули код=%d\n",m.mType,mm.mText,tt);
printQ(Q);

m.mType=1;tt=sys_msgrcv(Q,&mm,1,0.1, m.mType ); //считаем     
printf("считал из  из очереди тип=%2ld >%s<  вернули код=%d\n",m.mType,mm.mText,tt);
printQ(Q);




//7.В конце отделяем сегмент общей памяти от адресного пространства. Это также приведёт к разблокировке этого сегмента, если он блокирован
printf("выход\n");
munmap(Q->addr, sizeof(myQsys_type));

}

=============================================  описание месенджера из задания 13 ========================================
Задания на очереди сообщений, мессенджер

1. Начал с простого в system V, использовал там две очереди, хотя легко можно было обойтись одной
2. В posix показалось слишком просто , и из спортивного интереса обошелся одной очередью -  

3. Создать месенджер - вот здесь по неопытности столкнулся с кучей проблем,  и быстро нарастающей сложности, убил кучу времени и
в итоге сделал "лишь бы формально работало", очень некрасивого  и проблемного кода, показывающего как делать не надо. :)
От попытки все реализовать в общем случае отказался из за возникших сложностей, хотя в архитектуре заложенно на полноценный месенджер.

ОШИБКИ и ВЫВОДЫ:
1 - недостаточно четкое проектирование на бумаге, проблемы с архитектурой + ошибки в ней,+ в какой то момент  
    структуры сообщения пид-клиент оказалось недостаточно 
2 - Начал с интерфейса, с переделки файлового менеджера, в итоге потом была архитектурная отладка с большой кучей кода
3.- Слишком раннее разделение на клиента и сервера, типа посмотреть что получилось. В итоге архитектурные правки пришлось вносит сразу в 2 
экземпляра. да и просто  беспорядок и путаница в почти одинаковом коде.
4. Поленился продумать функции, это упростило бы отладку

ИДЕЯ И АЛГОРИТМ РАБОТЫ
1. клиент и сервер это программы с одним интерфейсом, 
2. Ядро  программы - модуль dinamic_msg.c и структура данных, описывающая клиента как чат комнату, комнаты между клиентами в общем случае это тот же обьект
   чат-комната, со свойством privat, что бы потом остальным была не видна. Сообщения в комнате компануются в динамически выделяемую память,подряд
   но есть указатель на начало области и список смещений относительно него на каждое сообщение.

3.Общая комната вынесена отдельно и имеет ID 0, остальные клиенты имеют ID - pid процесса, в общем случае это не совсем правильно, но сделал так.

4. Итак имеем два приложения - КЛИЕНТ и Сервер, в каждом приложении 2 потока плюс основной(отвечающий за интерфейс) итого 3 потока на приложение. Взаимодействующие между собой по стандарту systemV ( идеально ложиться на архитектуру клиент - сервер)

    Задача потока 1 -  слушать регистрацию клиентов, очередь сообщений 1 + управляющие команды
    Задача потока 2 - обмен сообщениями, очередь сообщений 2 + управляющие команды
    
    Каждая очередь (и процесс) пработают в режиме  вопрос-ответ, т.е. по умолчанию мы слушаем очередь, и если что то считываем из нее - выполняем соответствующее действия
    в итоге , появились мета-команды между потоками - , например "send_msg" говорит потоку 2 сервера что нужно разослать последнее сообщение из чат-комнаты 
   (от сервера) всем клиентам, или команда " exit" говорит потоку что будем завершаться. Или команда от процесса 1 процессу 2  что появился новый клиент, 
   и нужно ему скинуть все сообщения из чат комнаты. Это механизм общения между потоками в одном приложении.
   
  5. Взаимодействие между приложениями устроено так - клиент отсылает серверу сообщение, которое тот добавляет в свою чат комнату,  и уже потом синхронизирует чат комнаты между всеми клиентами, включая того которой ему данное сообщение послал
  Стандартное сообщение от клиента выглядит так [свой_pid кому_pid/0 сообщение] 0 - для общей комнаты
  
  В итоге, сервер зная кто послал может отправить этому же клиенту ответку, (что даже не нужно оказалось) но пририсовывает к сообщению расшифровку - имя клиента (нужно).
  
  Ну вот. Из этого пришлось все ускорять, и реализованно только общие механизмы и то что касается общей чат комнаты, где то не до конца раскиданы мьютексы по графике( отрисовка сбоит) , приложения не договариваются между собой о корректном выходе, нет механизма блокировок чат комнат ну и 
  сам код надо сделать нормальным, сейчас там бардак.
  
  В начале запустите сервер, потом клиентов
        
